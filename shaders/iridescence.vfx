//=========================================================================================================================
// Optional
//=========================================================================================================================
HEADER
{
	CompileTargets = ( IS_SM_50 && ( PC || VULKAN ) );
	Description = "Iridescene";
	DevShader = true;
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
FEATURES
{
    #include "common/features.hlsl"

	Feature( F_DEBUG, 0..1, "Debug" );
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
MODES
{
    VrForward();													// Indicates this shader will be used for main rendering
    Depth( "vr_depth_only.vfx" ); 									// Shader that will be used for shadowing and depth prepass
    ToolsVis( S_MODE_TOOLS_VIS ); 									// Ability to see in the editor
    ToolsWireframe( "vr_tools_wireframe.vfx" ); 					// Allows for mat_wireframe to work
	ToolsShadingComplexity( "vr_tools_shading_complexity.vfx" ); 	// Shows how expensive drawing is in debug view
}

//=========================================================================================================================
COMMON
{
	#include "common/shared.hlsl"
	#include "vr_common.fxc"

	#define VS_INPUT_HAS_TANGENT_BASIS 1
    #define PS_INPUT_HAS_TANGENT_BASIS 1
}

//=========================================================================================================================

struct VertexInput
{
	#include "common/vertexinput.hlsl"
};

//=========================================================================================================================

struct PixelInput
{
	#include "common/pixelinput.hlsl"
};

//=========================================================================================================================

VS
{
	#include "common/vertex.hlsl"
	//
	// Main
	//
	PixelInput MainVs( INSTANCED_SHADER_PARAMS( VS_INPUT i ) )
	{
		PixelInput o = ProcessVertex( i );
		// Add your vertex manipulation functions here
		return FinalizeVertex( o );
	}
}

//=========================================================================================================================

PS
{
    #include "common/pixel.hlsl"
    float g_flFresnelExponent < Default(2.0f); Range(0.0, 10.0); UiGroup("Iridescence,10/1");>;
    float g_flAlbedoFactor < Default(1.0f); Range(0.0, 1.0); UiGroup("Iridescence,10/2");>;
    float2 g_flDebugSplit < Default2(500.0f, 500.0f); Range2(0.0f, 0.0f, 1000.0f, 1000.f); UiGroup("Debug,10/1");>;
	
	//Gradient Map
	CreateInputTexture2D( TextureGradient,            Srgb,   8, "",                 "_color",  "Iridescence,10/3", Default3( 1.0, 1.0, 1.0 ) );
	CreateTexture2DWithoutSampler( g_tIridescenceGradient ) < Channel( RGBA, Box( TextureGradient ), Srgb ); OutputFormat( BC7 ); SrgbRead( true ); >;


	// Mask and Metal
	CreateInputTexture2D( TextureMask,            Linear,   8, "",                 "_mask",  "Iridescence,10/4", Default3( 1.0, 1.0, 1.0 ) );
	CreateInputTexture2D( TextureIridescenceMetal,            Linear,   8, "",                 "_metal",  "Iridescence,10/5", Default3( 1.0, 1.0, 1.0 ) );
	CreateTexture2DWithoutSampler( g_tMaskMetal ) < Channel( R, Box( TextureMask ), Linear ); Channel( G, Box( TextureIridescenceMetal ), Linear );OutputFormat( BC7 ); SrgbRead( false ); >;
    SamplerState g_sBilinearWrap < Filter( BILINEAR ); AddressU( WRAP ); AddressV( WRAP ); >;

	//
	// Main
	//
	PixelOutput MainPs( PixelInput i )
	{
		PixelOutput o;

		Material m = GatherMaterial( i );

		// Dot Product With Normal Mapping
		float3 normal = Vec3TsToWsNormalized(m.Normal * 2.0f - 1.0f, i.vNormalWs.xyz, i.vTangentUWs, i.vTangentVWs);
		float d = saturate( 1 - pow( abs( dot( normalize( g_vWorldToCameraOffset ), normal ) ), g_flFresnelExponent ) );


		// Gradient mapping
		float3 colorGradient = Tex2DS(g_tIridescenceGradient, g_sBilinearWrap, float2(d, 0.0));
		

		// Effect mask
		float mask = Tex2DS(g_tMaskMetal, g_sBilinearWrap, i.vTextureCoords.xy).r;

		// Albedo
		m.Albedo = lerp(m.Albedo, lerp(float3(1.0, 1.0, 1.0), m.Albedo, g_flAlbedoFactor) * colorGradient, mask);

		// Metal
		float iMetal = Tex2DS(g_tMaskMetal, g_sBilinearWrap, i.vTextureCoords.xy).g;
		m.Metalness = lerp(m.Metalness, iMetal, mask);

	    StaticCombo( S_DEBUG, F_DEBUG, Sys( PC ) );
		#if (S_DEBUG)
			if (i.vPositionSs.x < g_flDebugSplit.x)
			{
				if (i.vPositionSs.y < g_flDebugSplit.y)
				{
					//Show Fresnel
					o.vColor = float4(d.xxx, 1.0);
				}
				else
				{
					//Show Normal
					o.vColor = float4(normal.rgb, 1.0);
				}
			}
			else
			{
				if (i.vPositionSs.y < g_flDebugSplit.y)
				{
					//Show gradient color
					o.vColor = float4(colorGradient, 1.0);
				}
				else
				{
					//Show Final
					return FinalizePixelMaterial( i, m );
				}
			}
			return o;
		#endif

		return FinalizePixelMaterial( i, m );
	}
}